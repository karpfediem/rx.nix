package nixgen

import (
	"fmt"
	"github.com/karpfediem/rx.nix/codegen/internal/parse"
	"github.com/karpfediem/rx.nix/codegen/internal/util"
	"os"
	"sort"
	"strings"
)

func WriteResourceNix(path string, r parse.ResourceInfo) error {
	var b strings.Builder
	fmt.Fprintf(&b, "# Auto-generated by codegen. Do not edit.\n")
	fmt.Fprintf(&b, "{ lib, ... }:\n")
	fmt.Fprintf(&b, "let\n  inherit (lib) mkOption types;\n")
	fmt.Fprintf(&b, "in\n{\n")
	fmt.Fprintf(&b, "  options.rx.res.%s = mkOption {\n", util.SanitizeAttrIdent(r.Name))

	desc := r.Doc
	if desc == "" {
		desc = fmt.Sprintf("mgmt resource: %s (struct %s).", r.Name, r.StructName)
	}
	fmt.Fprintf(&b, "    description = ''%s'';\n", util.EscapeIndentedNix(desc))
	fmt.Fprintf(&b, "    type = types.attrsOf (types.submodule ({ name, ... }: {\n")
	fmt.Fprintf(&b, "      options = {\n")

	for _, f := range r.Fields {
		nixType := nixTypeForGo(f.GoType) // always nullable
		fmt.Fprintf(&b, "        %s = mkOption {\n", util.SanitizeAttrIdent(f.LangName))
		fmt.Fprintf(&b, "          type = %s;\n", nixType)
		if f.Doc != "" {
			fmt.Fprintf(&b, "          description = ''%s'';\n", util.EscapeIndentedNix(f.Doc))
		} else {
			fmt.Fprintf(&b, "          description = \"\";\n")
		}
		fmt.Fprintf(&b, "          default = null;\n") // safe to read everywhere
		fmt.Fprintf(&b, "        };\n")
	}

	fmt.Fprintf(&b, "      };\n")
	fmt.Fprintf(&b, "    }));\n")
	fmt.Fprintf(&b, "    default = {};\n")
	fmt.Fprintf(&b, "  };\n")
	fmt.Fprintf(&b, "}\n")

	return os.WriteFile(path, []byte(b.String()), 0o644)
}

func WriteDefaultNix(path string, files []string) error {
	sort.Strings(files)
	var b strings.Builder
	fmt.Fprintf(&b, "# Auto-generated by codegen. Do not edit.\n")
	fmt.Fprintf(&b, "{ lib, ... }: {\n")
	fmt.Fprintf(&b, "  imports = [\n")
	for _, f := range files {
		if !strings.HasSuffix(f, ".nix") || f == "default.nix" {
			continue
		}
		fmt.Fprintf(&b, "    ./%s\n", f)
	}
	fmt.Fprintf(&b, "  ];\n")
	fmt.Fprintf(&b, "}\n")
	return os.WriteFile(path, []byte(b.String()), 0o644)
}

func nixTypeForGo(goType string) string {
	base := func() string {
		switch {
		case strings.HasPrefix(goType, "[]"):
			inner := strings.TrimPrefix(goType, "[]")
			return fmt.Sprintf("types.listOf %s", nixPrim(inner))
		case strings.HasPrefix(goType, "map["):
			return "types.attrsOf types.str" // coarse but acceptable
		default:
			return nixPrim(goType)
		}
	}()
	return fmt.Sprintf("types.nullOr (%s)", base)
}

func nixPrim(goType string) string {
	gt := strings.TrimSpace(goType)
	switch gt {
	case "string", "*string":
		return "types.str"
	case "bool", "*bool":
		return "types.bool"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return "types.int"
	case "float32", "float64":
		return "types.float"
	default:
		return "types.str"
	}
}
